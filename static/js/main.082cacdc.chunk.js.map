{"version":3,"sources":["components/misc/FoodWords.js","components/misc/Taco.js","components/Home.js","components/CheckForm.js","components/App.js","index.js"],"names":["ADJECTIVES","SHELL_VERBS","MIXIN_VERBS","CONDIMENT_VERBS","SEASONING_VERBS","getWord","words","length","randomIndex","Math","floor","random","splice","FoodWords","this","adjectives","concat","shVerbs","mVerbs","cVerbs","seVerbs","type","verbs","VOWELS","MAX_SELECTED","shells","baseLayers","mixins","condiments","seasonings","options","undefined","thumbUrls","capitalized","string","charAt","toUpperCase","substring","randChoice","arr","randInt","int","toConjuncted","a","map","str","console","log","trim","reduce","sum","el","i","aOrAn","word","includes","Taco","config","title","configObject","foodWords","base","getAdjective","getTitle","description","word1","word2","getVerb","getDescriptionString","thumbnail","isTaco","Object","keys","option","fetch","response","json","choice","name","replace","push","COOKIE_KEY","Home","savedTacos","Cookies","getJSON","set","expires","path","state","tacos","saveTaco","bind","deleteAllTacos","getRandomTaco","saveTacoTitle","handleCheckToggle","props","location","history","cameFromHistory","newTacos","setState","prevState","filter","item","j","newTitle","e","preventDefault","randomTacoConfig","then","onCheck","darkMode","className","id","onChange","for","to","href","onClick","taco","key","index","handleThisDelete","deleteOneTaco","handleTitleSave","Component","TacoCard","handleText","target","value","handleSave","showForm","alt","src","onSubmit","SECTIONS","CheckForm","formSections","selected","loading","error","submitted","handleSelect","handleSubmit","getOptions","endpoints","endpoint","choices","unfilled","errorString","missed","checked","updated","prevSelected","shift","pathname","size","sizeUnit","color","section","slug","htmlFor","App","dark","toggleDarkMode","exact","render","component","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.082cacdc.chunk.js","sourcesContent":["// Lists of words to give when a user asks for a adjective or verb\nconst ADJECTIVES = [ \"delicious\", \"savory\", \"flavorful\", \"delectable\", \"amazing\", \"warm\", \"fulfilling\", \"aromatic\", \"fresh\", \"tasty\", \"tantalizing\", \"succulent\", \"yummy\", \"rich\", \"hearty\", \"intense\", \"enticing\", \"appetizing\", \"splendid\", \"distinctive\", \"heavenly\", \"tempting\", \"piquant\", \"luscious\", \"nectarous\", \"gratifying\", \"pleasant\", \"divine\"]\nconst SHELL_VERBS = [\"wrapped\", \"enveloped\", \"cradled\", \"covered\"]\nconst MIXIN_VERBS = [\"mixed\", \"complemented\", \"accompanied\", \"joined\"]\nconst CONDIMENT_VERBS = [\"dashed\", \"drizzled\", \"poured\", \"blanketed\", \"covered\", \"dolloped\", \"coated\", \"served\", \"spread\"]\nconst SEASONING_VERBS = [\"peppered\", \"sprinkled\", \"topped\", \"seasoned\"]\n\n// Removes and returns a random element from an array\nfunction getWord (words) {\n    if (words.length === 0) return null\n    const randomIndex = Math.floor(Math.random() * words.length)\n    return words.splice(randomIndex, 1)[0]\n}\n\n// This class takes our list of words in this file and will give a unique word each time it's asked for one.\n// E.g. if a new FoodWords is initialized, getAdjective() may return \"delicious\". Any subsequent calls can only return the remaining\n// words in the object's list as delicious has already been gotten and removed.\nexport default class FoodWords {\n\n    constructor () {\n        // We use concat to create a deep copy of the array of strings, rather than a reference\n        this.adjectives = ADJECTIVES.concat([])\n        this.shVerbs = SHELL_VERBS.concat([])\n        this.mVerbs = MIXIN_VERBS.concat([])\n        this.cVerbs = CONDIMENT_VERBS.concat([])\n        this.seVerbs = SEASONING_VERBS.concat([])\n    }\n\n    // Gets and removes one food adjective\n    getAdjective () {\n        return getWord(this.adjectives)\n    }\n\n    // Based on the given type of food, get a verb to go with it\n    getVerb (type) {\n        let verbs\n        switch (type) {\n            case \"shells\":\n                verbs = this.shVerbs\n                break\n            case \"mixins\":\n                verbs = this.mVerbs\n                break\n            case \"condiments\":\n                verbs = this.cVerbs\n                break\n            case \"seasonings\":\n                verbs = this.seVerbs\n                break\n            default:\n                return\n        }\n        return getWord(verbs)\n    }\n\n}\n","import FoodWords from \"./FoodWords\"\n\n// Useful variables\nconst VOWELS = [\"a\", \"e\", \"i\", \"o\", \"u\"]\nconst MAX_SELECTED = {\n    shells: 1,\n    baseLayers: 2,\n    mixins: 2,\n    condiments: 3,\n    seasonings: 1\n}\n\nconst options = {\n    shells: undefined,\n    baseLayers: undefined,\n    mixins: undefined,\n    condiments: undefined,\n    seasonings: undefined\n}\n\nconst thumbUrls = [\"https://www.thewholesomedish.com/wp-content/uploads/2019/06/The-Best-Classic-Tacos-550.jpg\", \"https://www.thewholesomedish.com/wp-content/uploads/2019/06/The-Best-Classic-Tacos-550.jpg\", \"https://emilybites.com/wp-content/uploads/2019/03/Chili-Cheese-Tacos-3b-620x620.jpg\", \"https://hips.hearstapps.com/hmg-prod.s3.amazonaws.com/images/screen-shot-2019-07-16-at-4-07-03-pm-1563307642.png?crop=0.9962825278810409xw:1xh;center,top&resize=480:*\"]\n\n// Returns a capitalized version of the given string\nfunction capitalized (string) {\n    return string.charAt(0).toUpperCase() + string.substring(1)\n}\n\n// Gets a random element from a given array\nfunction randChoice (arr) { return arr[randInt(arr.length)] }\n\n// Gets a random integer from the range of floor (inclusive) to int + floor (exclusive)\nfunction randInt (int, floor = 0) { return Math.floor(Math.random() * int) + floor }\n\n// Turns an array of strings into a string containing all strings in the array, separated by commas and the correct conjunctions\nfunction toConjuncted (arr) {\n    const a = arr.map(str => {\n        console.log(str)\n        return str.trim()\n    })\n    if (a.length === 1) {\n        return a[0]\n    } else if (a.length === 2) {\n        return a[0] + \" and \" + a[1]\n    } else {\n        return a.reduce((sum, el, i) => {\n            if (i === 0)\n                return el\n            else if (i === arr.length - 1)\n                return sum + \", and \" + el\n            else\n                return sum + \", \" + el\n        })\n    }\n}\n\n// Returns \"an\" or \"a\" depending on whether the passed word starts with a vowel or not\nfunction aOrAn (word) {\n    if (VOWELS.includes(word.charAt(0))) return \"an\"\n    return \"a\"\n}\n\n// Creates a description string using a taco config and a food word generator class\nfunction getDescriptionString (configObject, foodWords) {\n    const { shells, baseLayers, mixins, condiments, seasonings } = configObject\n    const word1 = foodWords.getAdjective(), word2 = foodWords.getAdjective()\n    return `${capitalized(aOrAn(word1))} ${word1} ${toConjuncted(baseLayers)} taco ${foodWords.getVerb(\"shells\")} in ${toConjuncted(shells)}, ${foodWords.getVerb(\"mixins\")} with some ${word2} ${toConjuncted(mixins)}, ${foodWords.getVerb(\"condiments\")} with ${toConjuncted(condiments)}, and ${foodWords.getVerb(\"seasonings\")} with ${toConjuncted(seasonings)} `\n}\n\n// Creates a title string using a taco config and a food word generator class\nfunction getTitle (configObject, foodWords) {\n    const base = toConjuncted(configObject.baseLayers)\n    return `${capitalized(aOrAn(base))} ${capitalized(foodWords.getAdjective())} ${base} Taco.`\n}\n\n// Taco class which takes a taco configuration and generates a title, description, and thumbnail\nexport default class Taco {\n\n    constructor (config) {\n        const words = new FoodWords()\n        this.title = getTitle(config, words)\n        this.description = getDescriptionString(config, words)\n        this.thumbnail = randChoice(thumbUrls) // Just get from 4 urls in an array above\n        this.config = config\n    }\n\n}\n\n// Calls the api to get ingredients and randomly assembles a taco based on our given ingredient count limits\nexport async function randomTacoConfig () {\n    const config = { isTaco: true }\n    for (const option of Object.keys(options)) {\n        // Fetch from endpoint if needed\n        if (options[option] === undefined) {\n            const response = await fetch(\"/\" + option)\n            options[option] = await response.json()\n            // Remove parenthesis in an ingredient name for readability\n            for (const choice of options[option]) {\n                let name = choice.name\n                if (name.includes(\"\\(\")) {\n                    choice.name = name.replace(/ *\\([^)]*\\) */g, \"\")\n                }\n            }\n        }\n        // Pick a random # of ingredients within our allowed range and then pick random, unique ingredients from the category lists\n        config[option] = []\n        for (let i = 0; i <= randInt(MAX_SELECTED[option]); i++) {\n            let choice = randChoice(options[option])\n            while (config[option].includes(choice.name))\n                choice = randChoice(options[option])\n            config[option].push(choice.name)\n        }\n    }\n    return config\n}\n","import React, { Component } from \"react\"\nimport { Link } from \"react-router-dom\"\nimport Taco, { randomTacoConfig } from \"./misc/Taco\"\nimport Cookies from \"js-cookie\"\nimport \"../sass/Home.scss\"\n\nconst COOKIE_KEY = \"tacos\"\n\nexport default class Home extends Component {\n\n    constructor () {\n        super()\n        // Set cookie if it doesn't exist\n        let savedTacos = Cookies.getJSON(COOKIE_KEY)\n        if (savedTacos === undefined) {\n            Cookies.set(COOKIE_KEY, [], { expires: 365, path: \"\" })\n            savedTacos = []\n        }\n        this.state = {\n            tacos: savedTacos\n        }\n        this.saveTaco = this.saveTaco.bind(this)\n        this.deleteAllTacos = this.deleteAllTacos.bind(this)\n        this.getRandomTaco = this.getRandomTaco.bind(this)\n        this.saveTacoTitle = this.saveTacoTitle.bind(this)\n        this.handleCheckToggle = this.handleCheckToggle.bind(this)\n    }\n\n    // On each load of this route, check whether a taco config was passed through the history stack. If so, save it\n    componentDidMount () {\n        // Get stuff off of the history stack\n        const config = this.props.location.state\n        if ((config !== null && config !== undefined) && config.isTaco) {\n            // Update saved tacos\n            this.saveTaco(config, true)\n        }\n        console.log(this.props.history)\n    }\n\n    // Given a configuration of a taco, containing baseLayer, mixins, etc., save it to our state array and locally in our cookie\n    saveTaco (config, cameFromHistory = false) {\n        // Update saved tacos\n        const newTacos = this.state.tacos.concat([new Taco(config)])\n        this.setState({ tacos: newTacos })\n        Cookies.set(COOKIE_KEY, newTacos)\n        if (cameFromHistory === true)\n            this.props.history.replace(\"/\", null)\n    }\n\n    // Deletes all created tacos\n    deleteAllTacos () {\n        this.setState({ tacos: [] })\n        // Update cookie\n        Cookies.set(COOKIE_KEY, [])\n    }\n\n    // Deletes one taco within our stored array, given by index\n    deleteOneTaco (i) {\n        this.setState((prevState) => {\n            const tacos = prevState.tacos.filter((item, j) => i != j)\n            Cookies.set(COOKIE_KEY, tacos)\n            return { tacos: tacos }\n        })\n    }\n\n    // Given a new title, replace the old with the new, given a taco index\n    saveTacoTitle (newTitle, i) {\n        this.setState((prevState) => {\n            const tacos = prevState.tacos.map((item, j) => {\n                if (i === j)\n                    return {\n                        ...item,\n                        title: newTitle\n                    }\n                return item\n            })\n            Cookies.set(COOKIE_KEY, tacos)\n            return { tacos: tacos }\n        })\n    }\n\n    // Fetch a random taco and save it to our list of tacos\n    getRandomTaco (e) {\n        e.preventDefault();\n        randomTacoConfig()\n        .then(config => {\n            this.saveTaco(config)\n        })\n    }\n\n    // Handler for passed function to toggle dark mode\n    handleCheckToggle (e) {\n        this.props.onCheck()\n    }\n\n    render () {\n        console.log(this.state.tacos)\n        const { tacos, darkMode } = this.state\n        return (\n            <div className=\"body\">\n                <h1>The Taco Generator!</h1>\n                <div>\n                    <input type=\"checkbox\" id=\"DarkMode\" onChange={this.handleCheckToggle} />\n                    <label for=\"DarkMode\">Dark Mode</label>\n                </div>\n                <p>This web app aims to solve man's greatest problem, which isn't climate change, nor is it the crumbling faith towards our institutions, but rather it's the question of what kind of taco should you or I eat. Click either of the two buttons to find out. </p>\n                <Link to=\"/form\" className=\"linkButton acc1\">Give me a new TACO!</Link>\n                <a href=\"#\" className=\"linkButton acc2\" onClick={this.getRandomTaco}>Surprise me with a Random TACO!</a>\n                <h3 className=\"acc2\">Your Tacos</h3>\n                <ul className=\"operations\">\n                    <li onClick={this.deleteAllTacos}>Delete All</li>\n                </ul>\n                <ul className=\"tacoList\">\n                    {tacos.length === 0 ? <p>Nothings here! We think you need more tacos in your life.</p> : null }\n                    {\n                        tacos.map((taco, i) => {\n                        return <TacoCard\n                            title={taco.title}\n                            description={taco.description}\n                            thumbnail={taco.thumbnail}\n                            key={i}\n                            index={i}\n                            handleThisDelete={this.deleteOneTaco.bind(this, i)}\n                            handleTitleSave={this.saveTacoTitle}\n                        />\n                    })\n                }\n                </ul>\n            </div>\n        )\n    }\n\n}\n\nclass TacoCard extends Component {\n\n    constructor (props) {\n        super(props)\n        this.state = {\n            title: this.props.title,\n            showForm: false\n        }\n    }\n\n    handleText = (e) => {\n        this.setState({ title: e.target.value })\n    }\n\n    handleSave = (e) => {\n        e.preventDefault()\n        this.setState({ showForm: false })\n        this.props.handleTitleSave(this.state.title, this.props.index)\n    }\n\n    render () {\n        const {title, showForm} = this.state\n        return (\n            <li className=\"tacoListItem\">\n                <div className=\"flexContainer\">\n                    <img alt=\"taco\" src={this.props.thumbnail} />\n                    <div className=\"textContainer\">\n                        <div className=\"tacoTitle\">{title}</div>\n                        <div className=\"tacoDescription\">{this.props.description}</div>\n                    </div>\n                </div>\n                <ul className=\"operations\">\n                    <li onClick={this.props.handleThisDelete}>Delete</li>\n                    <li onClick={(e) => this.setState({ showForm: !showForm })}>Edit Name</li>\n                    { showForm ?\n                    <form onSubmit={this.handleSave}>\n                        <input type=\"text\" value={title} onChange={this.handleText} />\n                        <input type=\"submit\" value=\"Submit\" />\n                    </form>\n                    : null }\n                </ul>\n            </li>\n        )\n    }\n\n}\n","import React, { Component } from \"react\"\nimport {SquareLoader} from \"react-spinners\"\nimport { Redirect, Link} from \"react-router-dom\"\nimport \"../sass/CheckForm.scss\"\n\n// Useful variables\nconst options = {\n    shells: \"Shells\",\n    baseLayers: \"Base Layers\",\n    mixins: \"Mixins\",\n    condiments: \"Condiments\",\n    seasonings: \"Seasonings\"\n}\n\nconst SECTIONS = []\nconst MAX_SELECTED = {\n    shells: 1,\n    baseLayers: 2,\n    mixins: 2,\n    condiments: 3,\n    seasonings: 1\n}\n\nexport default class CheckForm extends Component {\n\n    constructor () {\n        super()\n        this.state = {\n            formSections: SECTIONS.length > 0 ? SECTIONS : [],\n            selected: {\n                shells: [],\n                baseLayers: [],\n                mixins: [],\n                condiments: [],\n                seasonings: [],\n                isTaco: true\n            },\n            loading: true,\n            error: undefined,\n            submitted: false\n        }\n        this.handleSelect = this.handleSelect.bind(this)\n        this.handleSubmit = this.handleSubmit.bind(this)\n        this.getOptions()\n    }\n\n    // Calls the API to get our choices of ingredients for each given category and saves it to use later\n    async getOptions () {\n        if (SECTIONS.length > 0) return\n        const endpoints = Object.keys(options)\n        for (const endpoint of endpoints) {\n            const response = await fetch(`/${endpoint}`)\n            const choices = await response.json()\n            // Strip names of parenthesis to make ingredient more readable\n            for (const choice of Object.keys(choices)) {\n                let name = choices[choice].name\n                if (name.includes(\"\\(\")) {\n                    choices[choice].name = name.replace(/ *\\([^)]*\\) */g, \"\")\n                }\n            }\n            SECTIONS.push({\n                title: options[endpoint],\n                type: endpoint,\n                choices: choices\n            })\n        }\n        this.setState({ loading: false, formSections: SECTIONS })\n    }\n\n    // On submission, check whether the user filled in at least one choice for each ingredient category and pushes the taco configuration\n    // object (selected ingredients) onto the history stack, updating the components state to redirect to the root route on the next render\n    handleSubmit (e) {\n        e.preventDefault()\n        const selected = this.state.selected\n        let unfilled = []\n        for (const option of Object.keys(options)) {\n            if (selected[option].length === 0) {\n                unfilled.push(options[option])\n            }\n        }\n        // Check if everything has been filled\n        if (unfilled.length > 0) {\n            console.log(unfilled)\n            let errorString = \"Please fill out all options. You've missed the following categories: \"\n            errorString += unfilled.reduce((sum, missed, i) => {\n                if (i === 0) { return `${missed}` }\n                return `${sum}, ${missed}`\n            })\n            this.setState({ error: errorString })\n            return\n        }\n        this.setState({ submitted: true })\n    }\n\n    // With checkboxes being controlled input, updates state of checkboxes, adds selected ingredient to saved list of selected ingredients,\n    // and removes the oldest ingredient in the category if the max selected has been exceeded\n    handleSelect (e) {\n        const name = e.target.name, value = e.target.value, checked = e.target.checked\n        this.setState((prevState) => {\n            const prevSelected = prevState.selected, option = prevSelected[name]\n            let updated\n            if (checked) {\n                // Remove oldest element added\n                if (option.length + 1 > MAX_SELECTED[name])\n                    option.shift()\n                updated = option.concat([value])\n            } else {\n                updated = option.filter(item => item !== value)\n            }\n            console.log(updated)\n            return {\n                ...prevState,\n                selected: {\n                    ...prevSelected,\n                    [name]: updated\n                }\n            }\n        })\n    }\n\n    render () {\n        const { formSections, selected, loading, error, submitted } = this.state\n        if (submitted)\n            return <Redirect\n            to={{\n                pathname: \"/\",\n                state: selected\n            }}\n        />\n        return loading ?\n        (\n            <div className=\"body\">\n                <SquareLoader\n                    size={5}\n                    sizeUnit={\"rem\"}\n                    color={\"#FFB011\"}\n                    loading={true}\n                    className=\"loader\"\n                />\n                <p>Getting the ingredients...</p>\n            </div>\n        ) : (\n            <div className=\"body\">\n                <Link to=\"/\">Back to home</Link>\n                <h2>Build your Taco</h2>\n                <form onSubmit={this.handleSubmit.bind(this)}>\n                    { formSections.map((section, i) => {\n                        return (\n                            <section key={i}>\n                                <h4 className=\"acc2\">{section.title}</h4>\n                                <p>Can pick up to {MAX_SELECTED[section.type]} items</p>\n                                {\n                                    section.choices.map((choice, i) => {\n                                        return (\n                                            <div className=\"checkGroup\" key={i} >\n                                                <input\n                                                    type=\"checkbox\"\n                                                    name={section.type}\n                                                    value={choice.name}\n                                                    id={choice.slug}\n                                                    onChange={this.handleSelect}\n                                                    checked={selected[section.type].includes(choice.name) ? \"checked\" : \"\" }\n                                                />\n                                                <label htmlFor={choice.slug} >{choice.name}</label>\n                                            </div>\n                                        )\n                                    })\n                                }\n                            </section>\n                        )\n                    }) }\n                    { error !== undefined ? <div className=\"error\">{error}</div> : \"\" }\n                    <input type=\"submit\" value=\"Create a taco!\" />\n                </form>\n            </div>\n        )\n    }\n\n}\n","import React, { Component } from \"react\"\nimport { Route } from \"react-router-dom\"\nimport Home from \"./Home\"\nimport CheckForm from \"./CheckForm\"\nimport \"../sass/App.scss\"\n\nexport default class App extends Component {\n\n    constructor () {\n        super()\n        this.state = {\n            dark: false\n        }\n        this.toggleDarkMode = this.toggleDarkMode.bind(this)\n    }\n\n    toggleDarkMode () {\n        this.setState({ dark: !this.state.dark })\n    }\n\n    render () {\n        return (\n            <div className={ this.state.dark ? \"app dark\" : \"app\"}> \n                <Route exact path=\"/\" render={(props) => <Home {...props} onCheck={this.toggleDarkMode} />} />\n                <Route path=\"/form\" component={CheckForm} />\n            </div>\n        );\n    }\n\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport {HashRouter as Router} from \"react-router-dom\"\nimport App from './components/App'\n\nReactDOM.render(\n        <Router>\n            <App />\n        </Router>,\n    document.getElementById('root'))\n"],"sourceRoot":""}